<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calm Drone â€“ Particle Plane</title>
    <style>
        html,body{margin:0;padding:0;width:100%;height:100%;background:#0a0a0c;overflow:hidden;font-family:sans-serif;color:#bbb}
        canvas{width:100%;height:100%;display:block}
        #info{position:fixed;bottom:10px;left:10px;font-size:11px;pointer-events:none;opacity:0.6}
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="info">WebGPU particle plane â€“ move mouse to pan / wheel to zoom</div>

<script type="module">
const canvas = document.getElementById('c');
if (!navigator.gpu){document.getElementById('info').textContent='WebGPU not supported';throw new Error('No WebGPU');}

/* ---------- WebGPU SETUP ---------- */
const adapter = await navigator.gpu.requestAdapter();
const device  = await adapter.requestDevice();
const ctx     = canvas.getContext('webgpu');
const format  = navigator.gpu.getPreferredCanvasFormat();
ctx.configure({device,format,alphaMode:'opaque'});

/* ---------- PARTICLE DATA ---------- */
const N=120000; // calm density
const particleStride=24; // vec3 pos + vec3 vel (f32)
const particleBuf=device.createBuffer({
  size:N*particleStride,
  usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC
});
{
    const tmp=new Float32Array(N*6);
    for(let i=0;i<N;i++){
        // random position in [-2,2] cube
        tmp[i*6+0]=(Math.random()*2-1)*2;
        tmp[i*6+1]=(Math.random()*2-1)*2;
        tmp[i*6+2]=(Math.random()*2-1)*2;
        // small random vel
        tmp[i*6+3]=(Math.random()*2-1)*0.0002;
        tmp[i*6+4]=(Math.random()*2-1)*0.00002;
        tmp[i*6+5]=(Math.random()*2-1)*0.0002;
    }
    device.queue.writeBuffer(particleBuf,0,tmp);
}

/* ---------- UNIFORMS ---------- */
// time, aspect, yaw, pitch
const uniBuf=device.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});
const audioBuf=device.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}); // bass, mid, high, dummy
// control parameters: flowBase, flowAudioScale, viscosity, rippleBase
const paramBuf=device.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});
const impulseBuf=device.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}); // x, strength, hueShift, pad
const attractorBuf=device.createBuffer({size:8*16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}); // up to 8 attractors vec4

/* ---------- SHADERS ---------- */
const compMod=device.createShaderModule({code:`
struct P{pos:vec3<f32>,vel:vec3<f32>};
@group(0)@binding(0)var<storage,read_write> p:array<P>;
@group(0)@binding(1)var<uniform> u:vec4<f32>; // time, aspect, yaw, pitch
@group(0)@binding(2)var<uniform> a:vec4<f32>; // bass, mid, high, pad
@group(0)@binding(3)var<uniform> c:vec4<f32>; // flowBase, flowScale, viscosity, rippleBase
@group(0)@binding(4)var<uniform> s:vec4<f32>; // impulseX, strength, hue, pad
@group(0)@binding(5)var<uniform> at:array<vec4<f32>,8>; // attractors (xyz, strength)
const PARTICLE_COUNT: u32 = 120000u;
fn hash(n:vec3<f32>)->f32{return fract(sin(dot(n,vec3<f32>(12.9898,78.233,37.719)))*43758.5453);
}
// simple curl-ish noise
fn flow(pos:vec2<f32>,t:f32)->vec2<f32>{
  let n=vec2<f32>(sin(pos.y*3.+t*0.05),cos(pos.x*3.+t*0.05));
  return n*0.2;
}
@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id)id:vec3<u32>){
 let i = id.x;
 if(i >= PARTICLE_COUNT) {
   return;
 }
 var pp=p[i];
 let f=flow(pp.pos.xz, u.x);
 var delta: vec2<f32> = f * (c.x + (a.x + a.z) * c.y);
 // attraction forces
 for(var j:u32 = 0u; j<8u; j=j+1u){
   let att = at[j];
   let str = att.w;
   if(str>0.0001){
     let diff = att.xyz - pp.pos;
     let dist2 = max(dot(diff,diff), 0.001);
     let force = diff * (str/dist2)*0.002;
     pp.vel += force;
   }
 }
 // localized boost from impulse on x axis
 let dx = pp.pos.x - s.x;
 let boost = s.y * exp(-dx*dx*25.0);
 delta *= (1.0 + boost);
 pp.vel.x += delta.x;
 pp.vel.z += delta.y;
 pp.vel*=c.z; // viscosity
 pp.pos += pp.vel;
 // clamp to soft bounds
 if(length(pp.pos) > 4.0){ pp.pos = pp.pos * 0.5; pp.vel = pp.vel * -0.3; }
 p[i]=pp;
}`});

const vertFragMod=device.createShaderModule({code:`
struct P{pos:vec3<f32>,vel:vec3<f32>};
@group(0)@binding(0)var<storage,read> p:array<P>;
@group(0)@binding(1)var<uniform> u:vec4<f32>; // time, aspect, yaw, pitch
@group(0)@binding(2)var<uniform> a:vec4<f32>; // bass, mid, high, pad
@group(0)@binding(3)var<uniform> c:vec4<f32>; // flowBase, flowScale, viscosity, rippleBase
@group(0)@binding(4)var<uniform> s:vec4<f32>; // impulseX, strength, hue, pad
@group(0)@binding(5)var<uniform> at:array<vec4<f32>,8>;
struct VOut{@builtin(position)pos:vec4<f32>,@location(0)col:vec4<f32>};
const PARTICLE_COUNT: u32 = 120000u;
@vertex fn vs(@builtin(vertex_index)i:u32)->VOut{
 var out:VOut;
 let pr=p[i].pos;
 var world=pr;
 // camera (orbit)
 let yaw=u.z;let pitch=u.w;
 let cy = cos(yaw);
 let sy = sin(yaw);
 let cp = cos(pitch);
 let sp = sin(pitch);
 var v=vec3<f32>(
    world.x*cy - world.z*sy,
    world.x*sy + world.z*cy,
    world.y);
 var v2=vec3<f32>(v.x, v.z*cp - v.y*sp, v.z*sp + v.y*cp);
 let persp=1.0/(1.5+v2.y);
 let asp=u.y;
 out.pos=vec4<f32>(v2.x*persp/asp, v2.z*persp, 0.0, 1.0);
 
 // Calculate color based on z-position and hue from sound pitch
 let zColor = (world.z + 2.0) / 4.0; // normalize z from [-2,2] to [0,1]
 let hue = s.z + zColor * 0.5; // combine sonic pitch with z-position
 
 // Convert HSV to RGB (where V and S are influenced by audio)
 let h = fract(hue) * 6.0;
 let hi = floor(h);
 let f = h - hi;
 let p = 0.4;
 let q = p * (1.0 - f * (0.6 + 0.2 * a.y));
 let t = p * (1.0 - (1.0 - f) * (0.6 + 0.2 * a.y));
 var r = 0.0;
 var g = 0.0;
 var b = 0.0;
 
 if(hi < 1.0) { r = p; g = t; b = 0.3; }
 else if(hi < 2.0) { r = q; g = p; b = 0.3; }
 else if(hi < 3.0) { r = 0.3; g = p; b = t; }
 else if(hi < 4.0) { r = 0.3; g = q; b = p; }
 else if(hi < 5.0) { r = t; g = 0.3; b = p; }
 else { r = p; g = 0.3; b = q; }
 
 // Adjust with audio reactivity
 r = r * (0.8 + 0.4 * a.x);
 g = g * (0.8 + 0.3 * a.y);
 b = b * (0.8 + 0.4 * a.z);
 
 out.col=vec4<f32>(r, g, b, 0.4+0.5*persp);
 return out;}
@fragment fn fs(in:VOut)->@location(0)vec4<f32>{
 return in.col;
}`});

// Tendril line shader (draws energy pulses along connections)
const tendrilMod=device.createShaderModule({code:`
struct VIn{ @location(0) pos:vec3<f32>, @location(1) energy:f32 };
@group(0) @binding(0) var<uniform> u:vec4<f32>; // time, aspect, yaw, pitch
@group(0) @binding(1) var<uniform> col:vec3<f32>; // base RGB color

struct VOut{ @builtin(position) pos:vec4<f32>, @location(0) energy:f32 };

// same camera transform as particles
fn project(p:vec3<f32>)->vec4<f32>{
  let yaw=u.z; let pitch=u.w;
  let cy=cos(yaw); let sy=sin(yaw);
  let cp=cos(pitch); let sp=sin(pitch);
  var v=vec3<f32>( p.x*cy - p.z*sy, p.x*sy + p.z*cy, p.y);
  var v2=vec3<f32>(v.x, v.z*cp - v.y*sp, v.z*sp + v.y*cp);
  let persp=1.0/(1.5+v2.y);
  let asp=u.y;
  return vec4<f32>(v2.x*persp/asp, v2.z*persp, 0.0, 1.0);
}

@vertex fn vs(in:VIn)->VOut{
  var out:VOut;
  out.pos = project(in.pos);
  out.energy = in.energy;
  return out;
}

@fragment fn fs(in:VOut)->@location(0) vec4<f32>{
  let e = clamp(in.energy, 0.0, 1.0);
  // bluish-white glow
  return vec4<f32>(0.3*e, 0.6*e+0.2*e*e, 1.0*e, e);
}`});

/* ---------- PIPELINES ---------- */
const compPipe=device.createComputePipeline({layout:'auto',compute:{module:compMod,entryPoint:'main'}});
const renderPipe=device.createRenderPipeline({layout:'auto',
  vertex:{module:vertFragMod,entryPoint:'vs'},
  fragment:{module:vertFragMod,entryPoint:'fs',targets:[{format,blend:{color:{srcFactor:'src-alpha',dstFactor:'one',operation:'add'},alpha:{srcFactor:'one',dstFactor:'one-minus-src-alpha',operation:'add'}}}]},
  primitive:{topology:'point-list'}
});

// Tendril pipeline (line list with additive blending)
const tendrilPipe=device.createRenderPipeline({layout:'auto',
  vertex:{module:tendrilMod,entryPoint:'vs',buffers:[{arrayStride:16,attributes:[{shaderLocation:0,offset:0,format:'float32x3'},{shaderLocation:1,offset:12,format:'float32'}]}]},
  fragment:{module:tendrilMod,entryPoint:'fs',targets:[{format,blend:{color:{srcFactor:'src-alpha',dstFactor:'one',operation:'add'},alpha:{srcFactor:'one',dstFactor:'one-minus-src-alpha',operation:'add'}}}]},
  primitive:{topology:'line-list'}
});

const compBG=device.createBindGroup({layout:compPipe.getBindGroupLayout(0),entries:[
  {binding:0,resource:{buffer:particleBuf}},
  {binding:1,resource:{buffer:uniBuf}},
  {binding:2,resource:{buffer:audioBuf}},
  {binding:3,resource:{buffer:paramBuf}},
  {binding:4,resource:{buffer:impulseBuf}},
  {binding:5,resource:{buffer:attractorBuf}}
]});
const renBG=device.createBindGroup({layout:renderPipe.getBindGroupLayout(0),entries:[
  {binding:0,resource:{buffer:particleBuf}},
  {binding:1,resource:{buffer:uniBuf}},
  {binding:2,resource:{buffer:audioBuf}},
  {binding:4,resource:{buffer:impulseBuf}}
]});

// Tendril resources
const TENDRIL_MAX_VERT = 512; // large enough for dense network lines
const tendrilBuf=device.createBuffer({size:TENDRIL_MAX_VERT*16,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});
const tendrilBG=device.createBindGroup({layout:tendrilPipe.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:uniBuf}}]});

/* ---------- AUDIO ---------- */
const ctxA=new (window.AudioContext||window.webkitAudioContext)();
const analyser=ctxA.createAnalyser();
analyser.fftSize=512;const freqData=new Uint8Array(analyser.frequencyBinCount);

// Generative FM drone
function createFmVoice(base){
  // Create more complex FM arrangement with nested modulation
  const carrier = ctxA.createOscillator();
  carrier.type = 'sine';
  carrier.frequency.value = base;
  
  // Primary modulator
  const mod1 = ctxA.createOscillator();
  mod1.type = 'sine'; 
  mod1.frequency.value = base * 0.5;
  
  // Secondary modulator (modulates the modulator for more complex timbres)
  const mod2 = ctxA.createOscillator();
  mod2.type = 'sine';
  mod2.frequency.value = base * 0.33;
  
  // LFO for subtle pitch variations
  const lfo = ctxA.createOscillator();
  lfo.type = 'sine';
  lfo.frequency.value = 0.1 + Math.random() * 0.2; // 0.1-0.3 Hz
  
  // Gains for modulation amounts
  const mod1Gain = ctxA.createGain();
  mod1Gain.gain.value = base * 0.3;
  
  const mod2Gain = ctxA.createGain();
  mod2Gain.gain.value = base * 0.15;
  
  const lfoGain = ctxA.createGain();
  lfoGain.gain.value = base * 0.05;
  
  // Connect secondary modulator to primary modulator
  mod2.connect(mod2Gain).connect(mod1.frequency);
  
  // Connect primary modulator to carrier
  mod1.connect(mod1Gain).connect(carrier.frequency);
  
  // Connect LFO to carrier for subtle pitch variations
  lfo.connect(lfoGain).connect(carrier.frequency);
  
  // Output gain with very short fade-in to prevent clicks
  const amp = ctxA.createGain();
  amp.gain.value = 0;
  
  // Filter for tone shaping
  const filter = ctxA.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 1000 + Math.random() * 1000;
  filter.Q.value = 1 + Math.random() * 5;
  
  carrier.connect(filter).connect(amp);
  
  // Start all oscillators
  mod1.start();
  mod2.start();
  lfo.start();
  carrier.start();
  
  // Small fade-in to avoid clicks
  const now = ctxA.currentTime;
  amp.gain.setValueAtTime(0, now);
  amp.gain.linearRampToValueAtTime(0.05, now + 0.01);
  
  return {carrier, mod1, mod2, lfo, mod1Gain, mod2Gain, lfoGain, amp, filter, baseFreq: base};
}

const voices=[55, 82.5, 110].map(createFmVoice);

// Cross-modulation between voices for more complex interplay
// Voice 0 slightly modulates voice 1, voice 1 slightly modulates voice 2, etc.
for (let i = 0; i < voices.length - 1; i++) {
  const crossModGain = ctxA.createGain();
  crossModGain.gain.value = voices[i+1].baseFreq * 0.02; // Subtle cross-modulation
  voices[i].carrier.connect(crossModGain).connect(voices[i+1].carrier.frequency);
}

const mix=ctxA.createGain();voices.forEach(v=>v.amp.connect(mix));
const master=ctxA.createGain();master.gain.value=0.0; // initially muted until user enables

// Dynamic compressor to prevent clipping
const compressor = ctxA.createDynamicsCompressor();
compressor.threshold.value = -15;  // Start compressing at -15 dB
compressor.knee.value = 10;        // Soft knee for more musical compression
compressor.ratio.value = 4;        // Moderate compression ratio
compressor.attack.value = 0.005;   // Fast attack to catch transients
compressor.release.value = 0.1;    // Moderate release for natural sound

// Limiter as a final safety against clipping
const limiter = ctxA.createDynamicsCompressor();
limiter.threshold.value = -1.5;    // Only catch peaks close to 0dB
limiter.knee.value = 0;            // Hard knee for true limiting
limiter.ratio.value = 20;          // Very high ratio for brick wall limiting
limiter.attack.value = 0.001;      // Very fast attack
limiter.release.value = 0.025;     // Fast release

// Audio activity tracker to scale volume based on active sounds
let activeVoices = 3; // Start with the 3 drone voices
const voiceCounter = {
  increment() {
    activeVoices++;
    this.updateMixGain();
  },
  decrement() {
    activeVoices = Math.max(3, activeVoices - 1); // Never below 3 (the drone voices)
    this.updateMixGain();
  },
  updateMixGain() {
    // Scale mix gain inversely with number of active voices
    // More voices = lower individual gain to prevent clipping
    const scaleFactor = 1 / Math.sqrt(activeVoices / 3);
    mix.gain.value = Math.min(0.85, scaleFactor);
  }
};

// Initialize mix gain
mix.gain.value = 0.85;

// Signal flow: voice amps â†’ mix â†’ compressor â†’ limiter â†’ master â†’ analyzer â†’ output
mix.connect(compressor);
compressor.connect(limiter);
limiter.connect(master);
master.connect(analyser).connect(ctxA.destination);

// More complex evolving parameters - smooth out transitions to avoid clicks
setInterval(()=>{
  voices.forEach(v=>{
    // random small changes with more parameters
    const now = ctxA.currentTime;
    const duration = 3 + Math.random() * 5; // 3-8 second transitions
    
    // Use exponentialRampToValueAtTime for smoother changes to frequency
    // Add small epsilon to avoid zero values which cause errors with exponential ramps
    
    // Evolve primary modulator frequency (with safety check)
    const newMod1Freq = Math.max(0.1, v.mod1.frequency.value * (0.75 + Math.random() * 0.5));
    v.mod1.frequency.setTargetAtTime(newMod1Freq, now, duration);
    
    // Evolve secondary modulator frequency (with safety check)
    const newMod2Freq = Math.max(0.1, v.mod2.frequency.value * (0.8 + Math.random() * 0.4));
    v.mod2.frequency.setTargetAtTime(newMod2Freq, now, duration);
    
    // Evolve modulation amounts - use setTargetAtTime for smoother transitions
    const newMod1Gain = Math.max(0.001, v.mod1Gain.gain.value * (0.7 + Math.random() * 0.6));
    v.mod1Gain.gain.setTargetAtTime(newMod1Gain, now, duration);
    
    const newMod2Gain = Math.max(0.001, v.mod2Gain.gain.value * (0.7 + Math.random() * 0.6));
    v.mod2Gain.gain.setTargetAtTime(newMod2Gain, now, duration * 1.5);
    
    // Occasionally change LFO rate
    if (Math.random() < 0.3) {
      const newLfoRate = 0.05 + Math.random() * 0.4;
      v.lfo.frequency.setTargetAtTime(newLfoRate, now, duration * 2);
    }
    
    // Occasionally change filter parameters
    if (Math.random() < 0.4) {
      const newFilterFreq = 800 + Math.random() * 1800;
      v.filter.frequency.setTargetAtTime(newFilterFreq, now, duration);
      
      const newFilterQ = 0.5 + Math.random() * 6;
      v.filter.Q.setTargetAtTime(newFilterQ, now, duration * 1.2);
    }
  });
}, 8000);

// UI toggle for audio
const audioBtn=document.createElement('button');
audioBtn.id='audioBtn';
audioBtn.textContent='ðŸ”‡ Audio';
Object.assign(audioBtn.style,{position:'fixed',top:'10px',right:'10px',padding:'6px 10px',fontSize:'12px',zIndex:'10',opacity:'0.8'});
document.body.appendChild(audioBtn);

let audioOn=false;
audioBtn.addEventListener('click',async()=>{
  if(!audioOn){
    await ctxA.resume();
    master.gain.setTargetAtTime(1,ctxA.currentTime,0.5);
    audioOn=true;
    audioBtn.textContent='ðŸ”Š Audio';
  }else{
    master.gain.setTargetAtTime(0,ctxA.currentTime,0.5);
    audioOn=false;
    audioBtn.textContent='ðŸ”‡ Audio';
  }
});

/* ---------- CAMERA ---------- */
let yaw=0,pitch=-0.35;
let targetYaw=0, targetPitch=-0.35;
let zoom=1.0, targetZoom=1.0;
let autoRotate=true, autoRotateSpeed=0.0001;
let globalRotateSpeed=0.00015;
let cameraTransitionSpeed=0.1;
let zoomModulationAmount=0.2;
let zoomModulationSpeed=0.0002;

// Physics parameter sets for transitions
const physicsSets = [
  // Default balanced set
  {
    flowBase: 0.0002,
    flowScale: 0.001,
    viscosity: 0.995,
    rippleBase: 0.03,
    particleSpeed: 1.0,
    attractorStrength: 0.8
  },
  // High-flow, more chaotic set
  {
    flowBase: 0.0005,
    flowScale: 0.002,
    viscosity: 0.98,
    rippleBase: 0.06,
    particleSpeed: 1.5,
    attractorStrength: 1.2
  },
  // Low-flow, more stable set
  {
    flowBase: 0.00012,
    flowScale: 0.0005,
    viscosity: 0.998,
    rippleBase: 0.01,
    particleSpeed: 0.7,
    attractorStrength: 0.5
  },
  // Vortex-like set
  {
    flowBase: 0.0003,
    flowScale: 0.0015,
    viscosity: 0.99,
    rippleBase: 0.04,
    particleSpeed: 1.2,
    attractorStrength: 1.0
  }
];

let currentPhysicsSet = 0;
let targetPhysicsSet = 0;
let physicsTransitionProgress = 1.0; // 1.0 = fully transitioned

// Grid for tracking particle density
const densityGrid = {
  resolution: 8, // 8x8x8 grid
  cells: new Float32Array(8*8*8).fill(0),
  highestDensityCell: {x: 0, y: 0, z: 0},
  
  // Reset all cell counts
  reset() {
    this.cells.fill(0);
  },
  
  // Add a particle to the appropriate grid cell
  addParticle(x, y, z) {
    // Convert from world space (-2 to 2) to grid space (0 to resolution-1)
    const gridX = Math.floor(((x + 2) / 4) * this.resolution);
    const gridY = Math.floor(((y + 2) / 4) * this.resolution);
    const gridZ = Math.floor(((z + 2) / 4) * this.resolution);
    
    // Bounds check
    if (gridX >= 0 && gridX < this.resolution && 
        gridY >= 0 && gridY < this.resolution &&
        gridZ >= 0 && gridZ < this.resolution) {
      // Increment the cell counter
      const index = gridX + (gridY * this.resolution) + (gridZ * this.resolution * this.resolution);
      this.cells[index]++;
    }
  },
  
  // Find the cell with the highest density
  findHighestDensity() {
    let maxDensity = 0;
    let maxIndex = 0;
    
    for (let i = 0; i < this.cells.length; i++) {
      if (this.cells[i] > maxDensity) {
        maxDensity = this.cells[i];
        maxIndex = i;
      }
    }
    
    // Convert index back to 3D coordinates
    const gridZ = Math.floor(maxIndex / (this.resolution * this.resolution));
    const remaining = maxIndex % (this.resolution * this.resolution);
    const gridY = Math.floor(remaining / this.resolution);
    const gridX = remaining % this.resolution;
    
    // Convert from grid space to world space (center of the cell)
    const worldX = ((gridX + 0.5) / this.resolution * 4) - 2;
    const worldY = ((gridY + 0.5) / this.resolution * 4) - 2;
    const worldZ = ((gridZ + 0.5) / this.resolution * 4) - 2;
    
    this.highestDensityCell = {x: worldX, y: worldY, z: worldZ, density: maxDensity};
    return this.highestDensityCell;
  }
};

canvas.addEventListener('mousemove',e=>{
  if(e.buttons){
    autoRotate=false; // Disable auto-rotation when manually moving
    targetYaw+=e.movementX*0.002;
    targetPitch+=e.movementY*0.002;
    targetPitch=Math.max(-1.2,Math.min(-0.1,targetPitch));
  }
});

canvas.addEventListener('wheel',e=>{
  targetZoom=Math.max(0.5,Math.min(2.0,targetZoom+e.deltaY*-0.0005));
});

function updateCamera(deltaTime) {
  // Smooth transitions to target values
  yaw += (targetYaw - yaw) * cameraTransitionSpeed;
  pitch += (targetPitch - pitch) * cameraTransitionSpeed;
  zoom += (targetZoom - zoom) * (cameraTransitionSpeed * 0.5);
  
  // Apply auto-rotation if enabled
  if(autoRotate) {
    // Rotate on camera axis (yaw)
    targetYaw += autoRotateSpeed * deltaTime;
    
    // Apply subtle global rotation on pitch
    targetPitch += Math.sin(performance.now() * 0.0001) * globalRotateSpeed * deltaTime;
    targetPitch = Math.max(-1.2, Math.min(-0.1, targetPitch));
  }
  
  // Subtle zoom modulation
  targetZoom = 1.0 + Math.sin(performance.now() * zoomModulationSpeed) * zoomModulationAmount;
  
  // If we're tracking density, adjust camera to point at highest density area
  if (autoRotate && densityGrid.highestDensityCell) {
    const highDensity = densityGrid.highestDensityCell;
    
    // Calculate angle to highest density cell
    // Simple version: just adjust yaw to face the x,z position of the highest density
    const angleToTarget = Math.atan2(highDensity.z, highDensity.x);
    
    // Gradually adjust target yaw to face this direction
    const currentAngle = targetYaw % (Math.PI * 2);
    let angleDiff = angleToTarget - currentAngle;
    
    // Handle wrapping for smoothest rotation
    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    
    // Adjust target with a slow weighting to avoid jerky movements
    targetYaw += angleDiff * 0.002 * deltaTime;
    
    // Adjust pitch slightly based on y-position of highest density
    const pitchToTarget = -0.35 + (highDensity.y / 4) * 0.2; 
    targetPitch += (pitchToTarget - targetPitch) * 0.001 * deltaTime;
    targetPitch = Math.max(-1.2, Math.min(-0.1, targetPitch));
  }
}

function triggerCameraMovement() {
  // Move to a new random viewing angle, but keep looking at center
  targetYaw = yaw + (Math.random() * 2 - 1) * 0.8;
  targetPitch = -0.35 + (Math.random() * 2 - 1) * 0.2;
  targetPitch = Math.max(-1.2, Math.min(-0.1, targetPitch));
  
  // Quick transition
  cameraTransitionSpeed = 0.08 + Math.random() * 0.04;
  
  // Enable auto rotation
  autoRotate = true;
  
  // Randomize rotation speeds slightly
  autoRotateSpeed = 0.00008 + Math.random() * 0.00004;
  globalRotateSpeed = 0.0001 + Math.random() * 0.00005;
  
  // Set random zoom level
  targetZoom = 0.8 + Math.random() * 0.4;
  
  // Randomize zoom modulation
  zoomModulationAmount = 0.1 + Math.random() * 0.1;
  zoomModulationSpeed = 0.0001 + Math.random() * 0.0001;
  
  // Transition to a new physics set
  const newPhysicsSet = Math.floor(Math.random() * physicsSets.length);
  // Try to avoid choosing the same set
  targetPhysicsSet = (newPhysicsSet === currentPhysicsSet) ? 
    (currentPhysicsSet + 1) % physicsSets.length : newPhysicsSet;
  physicsTransitionProgress = 0.0; // Start transition
}

// Function to get interpolated physics values
function getCurrentPhysicsParams() {
  // If transition complete, just return target set values
  if (physicsTransitionProgress >= 1.0) {
    return physicsSets[currentPhysicsSet];
  }
  
  // Otherwise interpolate between current and target
  const current = physicsSets[currentPhysicsSet];
  const target = physicsSets[targetPhysicsSet];
  const t = physicsTransitionProgress;
  
  return {
    flowBase: current.flowBase + (target.flowBase - current.flowBase) * t,
    flowScale: current.flowScale + (target.flowScale - current.flowScale) * t,
    viscosity: current.viscosity + (target.viscosity - current.viscosity) * t,
    rippleBase: current.rippleBase + (target.rippleBase - current.rippleBase) * t,
    particleSpeed: current.particleSpeed + (target.particleSpeed - current.particleSpeed) * t,
    attractorStrength: current.attractorStrength + (target.attractorStrength - current.attractorStrength) * t
  };
}

/* ---------- FRAME LOOP ---------- */
let lastTime = performance.now();
let start=performance.now();
function frame(){
  const now = performance.now();
  const deltaTime = now - lastTime;
  lastTime = now;
  
  const t=(now-start)/1000;
  
  // Update camera animations
  updateCamera(deltaTime);
  
  // Update physics transition if in progress
  if (physicsTransitionProgress < 1.0) {
    physicsTransitionProgress = Math.min(1.0, physicsTransitionProgress + 0.003);
    
    // If we've reached the end of transition, update current set
    if (physicsTransitionProgress >= 1.0) {
      currentPhysicsSet = targetPhysicsSet;
    }
  }
  
  // Get current interpolated physics parameters
  const physics = getCurrentPhysicsParams();
  if(!paramLocked.flowBase) flowBase = physics.flowBase;
  if(!paramLocked.flowScale) flowScale = physics.flowScale;
  if(!paramLocked.viscosity) viscosity = physics.viscosity;
  if(!paramLocked.rippleBase) rippleBase = physics.rippleBase;
  
  // Reset density grid for this frame
  densityGrid.reset();
  
  // Density analysis needs to be done on CPU by reading back particle buffer
  // We'll do this periodically (not every frame to save performance)
  if (frameCount % 30 === 0) { // Every 30 frames, ~twice per second
    const readbackBuffer = device.createBuffer({
      size: N * particleStride,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    
    const encoder = device.createCommandEncoder();
    encoder.copyBufferToBuffer(particleBuf, 0, readbackBuffer, 0, N * particleStride);
    device.queue.submit([encoder.finish()]);
    
    // Schedule buffer readback and density analysis
    setTimeout(async () => {
      await readbackBuffer.mapAsync(GPUMapMode.READ);
      const data = new Float32Array(readbackBuffer.getMappedRange());
      
      // Analyze a subset of particles for efficiency
      const sampleSize = 5000; // Check ~5000 particles
      const stride = Math.floor(N / sampleSize);
      
      for (let i = 0; i < N; i += stride) {
        const x = data[i * 6];
        const y = data[i * 6 + 1];
        const z = data[i * 6 + 2];
        densityGrid.addParticle(x, y, z);
      }
      
      // Find highest density region
      densityGrid.findHighestDensity();
      
      readbackBuffer.unmap();
    }, 0);
  }
  
  analyser.getByteFrequencyData(freqData);
  // simplistic energy
  let bass=0,mid=0,high=0;
  for(let i=0;i<freqData.length;i++){
    const v=freqData[i]/255;
    if(i<10)bass+=v; else if(i<40) mid+=v; else high+=v;
  }
  bass/=10;mid/=30;high/=(freqData.length-40);
  // add decaying impact
  high+=impact;
  impact*=0.9;
  // generative evolution of simulation parameters
  if(!paramLocked.flowBase) flowBase += ((0.00015 + bass*0.00035) - flowBase) * 0.02;
  if(!paramLocked.flowScale) flowScale += ((0.0008 + bass*0.0015) - flowScale) * 0.02;
  if(!paramLocked.viscosity) viscosity += ((0.992 - high*0.01) - viscosity) * 0.02;
  viscosity = Math.min(Math.max(viscosity, 0.95), 0.999);
  if(!paramLocked.rippleBase) rippleBase += ((0.02 + mid*0.07 + impact*0.05) - rippleBase) * 0.05;
  rippleBase = Math.min(Math.max(rippleBase, 0), 0.1);
  // decay impulse strength
  impulseStrength*=0.96;
  // write uniforms (time block)
  device.queue.writeBuffer(uniBuf,0,new Float32Array([t,canvas.width/canvas.height,yaw,pitch*zoom]));
  // audio metrics buffer
  device.queue.writeBuffer(audioBuf,0,new Float32Array([bass,mid,high,0]));
  // impulse buffer update (strength decays)
  device.queue.writeBuffer(impulseBuf,0,new Float32Array([impulseX,impulseStrength,impulseHue,0]));
  // param buffer
  device.queue.writeBuffer(paramBuf,0,new Float32Array([flowBase,flowScale,viscosity,rippleBase]));
  // update attractors and buffer
  updateAttractors(physics.attractorStrength);
  const attArr=new Float32Array(32);
  // Central static attractor at origin, strength varies with audio (bass vs high energy)
  const centralStrength=Math.max(-1.5,Math.min(1.5,(bass-high)*1.5));
  attArr[0]=0;attArr[1]=0;attArr[2]=0;attArr[3]=centralStrength;
  // Fill remaining slots with dynamic attractors
  for(let k=0;k<attractors.length && k<DYN_ATTR_MAX;k++){
    const att=attractors[k];
    attArr[(k+1)*4+0]=att.x;
    attArr[(k+1)*4+1]=att.y;
    attArr[(k+1)*4+2]=att.z;
    attArr[(k+1)*4+3]=att.strength;
  }
  device.queue.writeBuffer(attractorBuf,0,attArr);

  // --- Build tendril vertex data (central to dynamic attractors) ---
  {
    const vArr=new Float32Array(TENDRIL_MAX_VERT*4);
    let vCount=0;
    const baseEnergy = 0.2 + high*0.9 + bass*0.3;
    const pushLine=(x1,y1,z1,x2,y2,z2,e)=>{
      if(vCount+2>=TENDRIL_MAX_VERT) return;
      vArr[vCount*4+0]=x1; vArr[vCount*4+1]=y1; vArr[vCount*4+2]=z1; vArr[vCount*4+3]=e*0.15; vCount++;
      vArr[vCount*4+0]=x2; vArr[vCount*4+1]=y2; vArr[vCount*4+2]=z2; vArr[vCount*4+3]=e; vCount++;
    };

    // Central origin to each attractor
    for(let i=0;i<attractors.length && i<DYN_ATTR_MAX;i++){
      const att=attractors[i];
      const pulse = 0.6+0.4*Math.sin(t*4 + i*1.3);
      const energy = Math.min(1, Math.abs(att.strength)*baseEnergy*pulse);
      pushLine(0,0,0, att.x, att.y, att.z, energy);
    }

    // Inter-attractor links for neural web
    for(let i=0;i<attractors.length;i++){
      const a=attractors[i];
      for(let j=i+1;j<attractors.length;j++){
        const b=attractors[j];
        const dist2=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z);
        if(dist2>linkDistance*linkDistance) continue;
        const energy=Math.min(1, baseEnergy*0.6/(1+dist2));
        pushLine(a.x,a.y,a.z, b.x,b.y,b.z, energy);
      }
    }

    // Spark nodes along attractor vectors for chaotic tendrils
    for(let i=0;i<attractors.length;i++){
      const att=attractors[i];
      const sparks=sparkCount;
      for(let s=0;s<sparks;s++){
        const tPos=Math.random()*0.8+0.1; // 0.1..0.9 fraction toward attractor
        const off= (Math.random()*2-1)*0.3;
        const sx=att.x*tPos + off;
        const sy=att.y*tPos + off;
        const sz=att.z*tPos + off;
        const energy=Math.min(1, baseEnergy*0.4*Math.random());
        pushLine(att.x,att.y,att.z, sx,sy,sz, energy);
        pushLine(0,0,0, sx,sy,sz, energy*0.5);
      }
    }
    tendrilVertexCount=vCount;
    device.queue.writeBuffer(tendrilBuf,0,vArr.subarray(0,vCount*4));
  }

  const enc=device.createCommandEncoder();
  const pass=enc.beginComputePass();
  pass.setPipeline(compPipe);pass.setBindGroup(0,compBG);pass.dispatchWorkgroups(Math.ceil(N/64));pass.end();
  const tex=ctx.getCurrentTexture().createView();
  const rpass=enc.beginRenderPass({colorAttachments:[{view:tex,clearValue:{r:0.03,g:0.03,b:0.05,a:1},loadOp:'clear',storeOp:'store'}]});
  rpass.setPipeline(renderPipe);rpass.setBindGroup(0,renBG);rpass.draw(N);
  // draw tendrils
  if(tendrilVertexCount>1){
    rpass.setPipeline(tendrilPipe);
    rpass.setBindGroup(0,tendrilBG);
    rpass.setVertexBuffer(0,tendrilBuf);
    rpass.draw(tendrilVertexCount);
  }
  rpass.end();
  device.queue.submit([enc.finish()]);
  
  // Update frame counter
  frameCount++;
  
  requestAnimationFrame(frame);
}

let frameCount = 0;
let tendrilVertexCount = 0;
requestAnimationFrame(frame);

/* ---------- RESIZE ---------- */
function resize(){
  const dpr = window.devicePixelRatio || 1;
  canvas.width = canvas.clientWidth * dpr;
  canvas.height = canvas.clientHeight * dpr;
}
window.addEventListener('resize',resize);resize();

// Control Panel
const controls=document.createElement('div');
Object.assign(controls.style,{position:'fixed',top:'10px',left:'10px',padding:'8px 12px',background:'rgba(20,20,25,0.6)',color:'#ccc',fontSize:'12px',borderRadius:'4px',zIndex:'10'});
document.body.appendChild(controls);

function addSlider(label,min,max,step,init,callback){
  const wrapper=document.createElement('div');
  wrapper.style.marginBottom='4px';
  const lab=document.createElement('label');lab.textContent=label;lab.style.display='block';
  const input=document.createElement('input');input.type='range';input.min=min;input.max=max;input.step=step;input.value=init;
  input.style.width='120px';
  input.addEventListener('input',()=>callback(parseFloat(input.value)));
  wrapper.appendChild(lab);wrapper.appendChild(input);controls.appendChild(wrapper);
}

// Parameters
let flowBase=0.0002, flowScale=0.001, viscosity=0.995, rippleBase=0.03;
// Tendril parameters
let sparkCount=2;
let linkDistance=3.0; // units in world space
// Track whether a parameter has been manually overridden by the user (locked)
const paramLocked={flowBase:false,flowScale:false,viscosity:false,rippleBase:false};

addSlider('Flow Strength',0,0.001,0.00005,flowBase,v=>{flowBase=v;paramLocked.flowBase=true;});
addSlider('Flow Bass Scale',0,0.005,0.00025,flowScale,v=>{flowScale=v;paramLocked.flowScale=true;});
addSlider('Viscosity',0.9,0.999,0.0005,viscosity,v=>{viscosity=v;paramLocked.viscosity=true;});
addSlider('Ripple Amp',0,0.1,0.005,rippleBase,v=>{rippleBase=v;paramLocked.rippleBase=true;});
addSlider('Volume',0,1,0.05,0,v=>{if(audioOn)master.gain.value=v;});

// Spark and link controls
addSlider('Spark Count',1,10,1,sparkCount,v=>{sparkCount=v;});
addSlider('Link Distance',1,6,0.5,linkDistance,v=>{linkDistance=v;});

// Color picker helper
function addColorPicker(label,init,cb){
  const wrapper=document.createElement('div');wrapper.style.marginBottom='4px';
  const lab=document.createElement('label');lab.textContent=label;lab.style.display='block';
  const input=document.createElement('input');input.type='color';input.value=init;
  input.addEventListener('input',()=>cb(input.value));
  wrapper.appendChild(lab);wrapper.appendChild(input);controls.appendChild(wrapper);
}

addColorPicker('Tendril Color','#4d99ff',hex=>{
  const r=parseInt(hex.substr(1,2),16)/255;
  const g=parseInt(hex.substr(3,2),16)/255;
  const b=parseInt(hex.substr(5,2),16)/255;
  tendrilColor=[r,g,b];
  device.queue.writeBuffer(tendrilColorBuf,0,new Float32Array(tendrilColor));
});

// ---- Attractor management ----
const ATTR_COUNT=8;
const DYN_ATTR_MAX = ATTR_COUNT - 1; // reserve index 0 for central static attractor
const attractors=[];
function addAttractor(){
  if(attractors.length>=DYN_ATTR_MAX)attractors.shift();
  
  // Add new attractor near the current highest density region with some variation
  let x, y, z;
  if (densityGrid.highestDensityCell && Math.random() < 0.6) {
    // 60% chance of spawning near high density
    const cell = densityGrid.highestDensityCell;
    x = cell.x + (Math.random() * 2 - 1) * 1.0;
    y = cell.y + (Math.random() * 2 - 1) * 1.0;
    z = cell.z + (Math.random() * 2 - 1) * 1.0;
  } else {
    // Otherwise random position
    x = (Math.random() * 2 - 1) * 2;
    y = (Math.random() * 2 - 1) * 2;
    z = (Math.random() * 2 - 1) * 2;
  }
  
  // Use current physics set for attractor strength
  const physics = getCurrentPhysicsParams();
  attractors.push({x, y, z, strength: physics.attractorStrength});
}

function updateAttractors(baseStrength = 0.8){
  for(let i=0;i<attractors.length;i++){
    // Decay attractors over time
    attractors[i].strength *= 0.995;
    
    // Remove weak attractors
    if(attractors[i].strength < 0.02){
      attractors.splice(i,1);
      i--;
    }
  }
}

// --- Generative FM chord events replacing noise clicks ---
let impact=0;
let lastChordType = 0; // For progression tracking

// Chord types (emotional/moody progressions)
const chordTypes = [
  // Minor seventh (moody/jazzy)
  [1, 6/5, 3/2, 9/5],
  // Half-diminished (tension)
  [1, 6/5, 3/2, 8/5],
  // Minor ninth (melancholic) 
  [1, 6/5, 3/2, 9/5, 11/5],
  // Minor add11 (atmospheric)
  [1, 6/5, 3/2, 11/6, 2],
  // Suspended fourth (floating)
  [1, 4/3, 3/2, 2]
];

function triggerChord(){
  // Choose a chord type that's different from the last one
  let chordTypeIndex;
  do {
    chordTypeIndex = Math.floor(Math.random() * chordTypes.length);
  } while (chordTypeIndex === lastChordType && chordTypes.length > 1);
  lastChordType = chordTypeIndex;
  
  // Use lower frequencies (down an octave)
  const baseFreq = 32.7 * Math.pow(2, Math.floor(Math.random() * 2)); // Lower register (C1-C2)
  const chordRatios = chordTypes[chordTypeIndex];
  
  // Calculate a hue value based on the chord type
  const hueBase = chordTypeIndex / chordTypes.length;
  
  const now = ctxA.currentTime;
  
  // Trigger camera movement
  triggerCameraMovement();
  
  // Choose 3-4 notes from the chord
  const notesToPlay = 3 + Math.floor(Math.random() * 2);
  const indices = Array.from({length: chordRatios.length}, (_, i) => i);
  
  // Shuffle array to randomly select notes
  for (let i = indices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  
  // Play selected notes
  for (let i = 0; i < notesToPlay; i++) {
    const idx = indices[i];
    const note = baseFreq * chordRatios[idx];
    addAttractor();
    
    // Enhanced FM synthesis for chord notes
    const carrier = ctxA.createOscillator();
    carrier.type = 'sine';
    carrier.frequency.value = note;
    
    // Primary modulator
    const mod = ctxA.createOscillator();
    mod.type = 'sine';
    
    // Varied modulator ratios for more timbral variation
    const modRatio = [1.5, 2, 2.5, 0.5, 0.75][Math.floor(Math.random() * 5)];
    mod.frequency.value = note * modRatio;
    
    // Secondary modulator for richer timbres
    const mod2 = ctxA.createOscillator();
    mod2.type = 'sine';
    mod2.frequency.value = note * (Math.random() < 0.5 ? 1/3 : 2/3);
    
    // Modulation gains
    const modGain = ctxA.createGain();
    const modDepth = note * (0.2 + Math.random() * 0.4); // Varied modulation depth
    modGain.gain.value = modDepth;
    
    const mod2Gain = ctxA.createGain();
    mod2Gain.gain.value = modDepth * 0.3;
    
    // Connect modulators
    mod2.connect(mod2Gain).connect(mod.frequency);
    mod.connect(modGain).connect(carrier.frequency);
    
    // Amplitude envelope with smoother transitions to avoid clicks
    const amp = ctxA.createGain();
    amp.gain.setValueAtTime(0, now); // Start at zero
    
    // Define duration
    const dur = 8 + Math.random() * 12; // 8-20s
    
    // Smoother attack to avoid clicks
    const attackTime = 1.5 + Math.random() * 1.5; // 1.5-3s
    amp.gain.linearRampToValueAtTime(0.01, now + 0.01); // Quick initial ramp to avoid clicks
    amp.gain.linearRampToValueAtTime(0.1, now + attackTime * 0.4);
    amp.gain.linearRampToValueAtTime(0.2, now + attackTime);
    
    // Random slight dip in the middle for some notes (with smoother transitions)
    if (Math.random() < 0.3) {
      const dipTime = now + attackTime + (dur * 0.3);
      const dipValue = 0.1 + Math.random() * 0.05;
      amp.gain.setTargetAtTime(dipValue, dipTime - 0.5, 0.5); // Use setTargetAtTime for smoother transition
      amp.gain.setTargetAtTime(dipValue * 1.5, dipTime + 0.5, 0.5);
    }
    
    // Smoother release to avoid clicks
    amp.gain.setTargetAtTime(0.0001, now + dur - 1.0, 0.8);
    
    // Evolve modulation over time
    modGain.gain.setValueAtTime(modDepth, now);
    modGain.gain.linearRampToValueAtTime(modDepth * (0.5 + Math.random()), now + dur * 0.5);
    modGain.gain.linearRampToValueAtTime(modDepth * 0.3, now + dur);
    
    // Filter for tone shaping
    const filter = ctxA.createBiquadFilter();
    filter.type = Math.random() < 0.7 ? 'lowpass' : 'bandpass';
    filter.frequency.value = 800 + Math.random() * 2000;
    filter.Q.value = 0.5 + Math.random() * 2;
    
    // Evolve filter over time
    filter.frequency.linearRampToValueAtTime(200 + Math.random() * 400, now + dur);
    
    carrier.connect(filter).connect(amp).connect(mix);
    mod.start();
    mod2.start();
    carrier.start();
    carrier.stop(now + dur);
    
    // Track voice for dynamic gain control
    voiceCounter.increment();
    
    // Set up auto-cleanup when voice ends
    carrier.onended = () => voiceCounter.decrement();
  }
  
  // Visual impulse & impact
  impact = 1;
  impulseX = Math.random() * 2 - 1;
  impulseStrength = 1;
  impulseHue = hueBase + Math.random() * 0.1; // Hue based on chord type with slight variation
}

// Schedule more frequent chord events (every 3-5 seconds)
setInterval(() => {
  if (audioOn && Math.random() < 0.6) triggerChord();
}, 3000);

// ---- Transient pitched tones ----
// Minor pentatonic for moody phrases
const pentatonicScales = [
  // Minor pentatonic (classic moody)
  [1, 6/5, 4/3, 3/2, 9/5],
  // Japanese scale (ethereal)
  [1, 6/5, 5/4, 3/2, 9/5],
  // Blues scale (emotional)
  [1, 6/5, 45/32, 3/2, 9/5, 2]
];

function triggerPitchedTransient(){
  // Choose a random scale
  const scaleIdx = Math.floor(Math.random() * pentatonicScales.length);
  const scale = pentatonicScales[scaleIdx];
  
  // Lower root note
  const baseFreq = 55; // A1 root
  
  // Select note from scale
  const noteIdx = Math.floor(Math.random() * scale.length);
  const note = baseFreq * scale[noteIdx] * (Math.random() < 0.3 ? 2 : 1); // Occasional octave jump
  
  // Smaller camera movement
  const smallMovement = Math.random() < 0.7; // Increased chance
  if (smallMovement) {
    targetYaw = yaw + (Math.random() * 2 - 1) * 0.2;
    targetPitch = pitch + (Math.random() * 2 - 1) * 0.05;
    targetPitch = Math.max(-1.2, Math.min(-0.1, targetPitch));
    targetZoom = zoom + (Math.random() * 2 - 1) * 0.1;
    cameraTransitionSpeed = 0.12;
  }
  
  // Enhanced FM synthesis for transient tones
  const carrier = ctxA.createOscillator();
  carrier.type = 'sine';
  carrier.frequency.value = note;
  
  // Primary modulator with varied ratios
  const mod = ctxA.createOscillator();
  mod.type = 'sine';
  
  // More varied modulation ratios for interesting timbres
  const modRatio = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0][Math.floor(Math.random() * 6)];
  mod.frequency.value = note * modRatio;
  
  // Modulation amount
  const modGain = ctxA.createGain();
  const modDepth = note * (0.2 + Math.random() * 0.4);
  modGain.gain.value = modDepth;
  
  // LFO for subtle pitch variation
  const lfo = ctxA.createOscillator();
  lfo.type = 'sine';
  lfo.frequency.value = 4 + Math.random() * 6; // 4-10 Hz vibrato
  
  const lfoGain = ctxA.createGain();
  lfoGain.gain.value = note * 0.005; // Subtle vibrato
  
  // Connections
  mod.connect(modGain).connect(carrier.frequency);
  lfo.connect(lfoGain).connect(carrier.frequency);
  
  // Amplitude envelope with smoother transitions
  const amp = ctxA.createGain();
  const now = ctxA.currentTime;
  amp.gain.setValueAtTime(0, now);
  
  // Smoother attack/release envelope to avoid clicks
  const dur = 2 + Math.random() * 3; // 2-5s
  const attackTime = 0.1 + Math.random() * 0.4; // 0.1-0.5s
  
  // Initial quick fade-in to avoid clicks
  amp.gain.linearRampToValueAtTime(0.01, now + 0.005);
  
  // Multi-segment envelope with smoother transitions
  amp.gain.linearRampToValueAtTime(0.2, now + attackTime * 0.5);
  amp.gain.linearRampToValueAtTime(0.25, now + attackTime);
  
  // Evolve modulation over time (with smoother curves)
  modGain.gain.setValueAtTime(modDepth, now);
  modGain.gain.setTargetAtTime(modDepth * 0.2, now + dur * 0.3, dur * 0.3);
  
  // Decay phase - use setTargetAtTime for smoother fade-out
  amp.gain.setTargetAtTime(0.0001, now + dur * 0.7, dur * 0.2);
  
  // Filter for tone shaping
  const filter = ctxA.createBiquadFilter();
  filter.type = Math.random() < 0.5 ? 'lowpass' : 'bandpass';
  filter.frequency.value = 1000 + Math.random() * 3000;
  filter.Q.value = 1 + Math.random() * 4;
  
  // Evolve filter over time
  filter.frequency.exponentialRampToValueAtTime(300 + Math.random() * 700, now + dur);
  
  carrier.connect(filter).connect(amp).connect(mix);
  mod.start();
  lfo.start();
  carrier.start();
  carrier.stop(now + dur);

  // Set impulse parameters with more z-axis and scale influence
  impulseX = Math.random() * 2 - 1;
  impulseStrength = 0.8;
  
  // Calculate hue based on note pitch relative to scale
  impulseHue = (scaleIdx * 0.2) + (noteIdx / scale.length) * 0.6; // 0..0.8 hue shift
  
  // Track voice for dynamic gain control
  voiceCounter.increment();
  
  // Set up auto-cleanup when voice ends
  carrier.onended = () => voiceCounter.decrement();
}

// More frequent pitched transients (every 1-3 seconds)
setInterval(() => {
  if (audioOn && Math.random() < 0.4) triggerPitchedTransient();
}, 1500);

// impulse state vars
let impulseX=0,impulseStrength=0,impulseHue=0;

</script>
</body>
</html> 