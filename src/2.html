<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Curl‑Noise Audio‑Reactive Particles (WebGPU)</title>
<style>html,body{margin:0;height:100%;background:#000;overflow:hidden;}canvas{display:block;width:100%;height:100%;cursor:pointer;}</style>
</head>
<body>
<canvas id="gfx"></canvas>
<script type="module">
/************** constants **************/
const COUNT = 20000;
const WORKGROUP_SIZE = 64;
/************** Audio ******************/
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
const master = audioCtx.createGain(); master.gain.value = 0.35;
const analyser = audioCtx.createAnalyser(); analyser.fftSize = 1024;
master.connect(analyser).connect(audioCtx.destination);
const drone = audioCtx.createOscillator(); drone.type='sine'; drone.frequency.value=55; drone.start(); drone.connect(master);
function fmSplash(){ const car=audioCtx.createOscillator(),mod=audioCtx.createOscillator(),mg=audioCtx.createGain(),vg=audioCtx.createGain(); const base=110+Math.random()*220; car.frequency.value=base; mod.frequency.value=20+Math.random()*60; mg.gain.value=Math.random()*base*0.6; mod.connect(mg).connect(car.frequency); vg.gain.setValueAtTime(0,audioCtx.currentTime); vg.gain.exponentialRampToValueAtTime(0.5,audioCtx.currentTime+0.5); vg.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+4); car.connect(vg).connect(master); car.start(); mod.start(); car.stop(audioCtx.currentTime+4); mod.stop(audioCtx.currentTime+4);} setInterval(()=>{ if(audioCtx.state==='running' && Math.random()<0.7) fmSplash(); },2400);
/************** WebGPU setup ***********/
const canvas = document.getElementById('gfx');
if(!navigator.gpu){canvas.outerHTML='<h2 style="color:#fff;font-family:sans-serif;padding:2rem">WebGPU unsupported</h2>'; throw new Error('WebGPU unsupported');}
const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
const context = canvas.getContext('webgpu');
const format = navigator.gpu.getPreferredCanvasFormat();
let depthTex;
function resize(){ canvas.width = canvas.clientWidth * devicePixelRatio; canvas.height = canvas.clientHeight * devicePixelRatio; context.configure({device,format,alphaMode:'opaque'}); depthTex = device.createTexture({size:[canvas.width,canvas.height,1],format:'depth24plus',usage:GPUTextureUsage.RENDER_ATTACHMENT}); }
resize(); addEventListener('resize',resize);
/************** GPU Buffers ************/
const STRIDE = 32; // 2 × vec4<f32>
const particleBuffer = device.createBuffer({ size: COUNT * STRIDE, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
// seed
{
  const seed = new Float32Array(COUNT*8);
  for(let i=0;i<COUNT;i++){
    const j=i*8;
    seed[j+0]=(Math.random()*2-1)*6; seed[j+1]=(Math.random()*2-1)*6; seed[j+2]=(Math.random()*2-1)*6; seed[j+3]=1;
    seed[j+4]=(Math.random()*2-1)*0.1; seed[j+5]=(Math.random()*2-1)*0.1; seed[j+6]=(Math.random()*2-1)*0.1; seed[j+7]=0;
  }
  device.queue.writeBuffer(particleBuffer,0,seed);
}
/************** Uniforms ***************/
const UNI_SIZE = 16*4*2 + 4*4;
const uniformBuffer = device.createBuffer({ size: UNI_SIZE, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
/************** WGSL Shaders ***********/
const simShader = device.createShaderModule({ code:`
struct Uniforms{ proj:mat4x4<f32>, view:mat4x4<f32>, amp:f32, time:f32, dt:f32, pad:f32 };
@group(0) @binding(0) var<uniform> U : Uniforms;
struct Particle{ pos:vec4<f32>, vel:vec4<f32> };
@group(0) @binding(1) var<storage,read_write> particles : array<Particle>;
fn curlNoise(p:vec3<f32>, t:f32)->vec3<f32>{
  let n1 = vec3<f32>( sin(p.y+t*0.6), sin(p.z+t*0.7), sin(p.x+t*0.5) );
  let n2 = vec3<f32>( sin((p.y+1.3)*0.8+t*0.4), sin((p.z+2.1)*0.6+t*0.3), sin((p.x+3.7)*0.9+t*0.2) );
  return vec3<f32>( n1.y-n1.z + n2.x, n1.z-n1.x + n2.y, n1.x-n1.y + n2.z );
}
@compute @workgroup_size(${WORKGROUP_SIZE})
fn csMain(@builtin(global_invocation_id) gid : vec3<u32>){
  let idx : u32 = gid.x;
  if(idx >= arrayLength(&particles)) { return; }
  var p = particles[idx];
  let flow = curlNoise(p.pos.xyz*0.25, U.time) * (0.8 + U.amp*2.0);
  // integrate velocity & position safely (WGSL disallows swizzle assignment)
  var v = p.vel.xyz;
  v = (v + flow * U.dt) * 0.96;
  var pos = p.pos.xyz + v * U.dt;
  // wrap cube
  if(pos.x>8.0){pos.x-=16.0;} else if(pos.x<-8.0){pos.x+=16.0;}
  if(pos.y>8.0){pos.y-=16.0;} else if(pos.y<-8.0){pos.y+=16.0;}
  if(pos.z>8.0){pos.z-=16.0;} else if(pos.z<-8.0){pos.z+=16.0;}
  p.pos = vec4<f32>(pos,1.0);
  p.vel = vec4<f32>(v,0.0);
  particles[idx] = p;
}`});
const renderShader = device.createShaderModule({ code:`
struct Uniforms{ proj:mat4x4<f32>, view:mat4x4<f32>, amp:f32, time:f32, dt:f32, pad:f32 };
@group(0) @binding(0) var<uniform> U : Uniforms;
struct Particle{ pos:vec4<f32>, vel:vec4<f32> };
@group(0) @binding(1) var<storage,read> particles : array<Particle>;
struct VOut{ @builtin(position) pos:vec4<f32>, @location(0) col:vec4<f32> };
@vertex fn vs(@builtin(vertex_index) vid:u32)->VOut{
  var o:VOut;
  let P = particles[vid].pos.xyz;
  o.pos = U.proj * U.view * vec4<f32>(P,1.0);
  let depth = clamp((o.pos.z+20.0)/40.0,0.0,1.0);
  let hue = depth + U.amp*0.6 + sin(U.time + P.x*0.5 + P.y*0.3)*0.3;
  o.col = vec4<f32>( mix(vec3<f32>(0.2,0.8,1.0), vec3<f32>(1.0,0.1,0.8), hue), 1.0);
  return o;
}
@fragment fn fs(i:VOut)->@location(0) vec4<f32>{ return i.col; }`});
/************** Pipelines **************/
const simPipeline = device.createComputePipeline({ layout:'auto', compute:{module:simShader, entryPoint:'csMain'} });
const renderPipeline = device.createRenderPipeline({ layout:'auto', vertex:{module:renderShader, entryPoint:'vs'}, fragment:{module:renderShader, entryPoint:'fs', targets:[{format, blend:{color:{operation:'add',srcFactor:'one',dstFactor:'one'}, alpha:{operation:'add',srcFactor:'one',dstFactor:'one'}}}]}, primitive:{topology:'point-list'}, depthStencil:{format:'depth24plus',depthWriteEnabled:false,depthCompare:'less'} });
const bindGroup = device.createBindGroup({ layout:renderPipeline.getBindGroupLayout(0), entries:[{binding:0,resource:{buffer:uniformBuffer}}, {binding:1,resource:{buffer:particleBuffer}}] });
/************** Camera ***************/
let yaw=0,pitch=0,rad=10, tgtYaw=0,tgtPitch=0,tgtRad=10,nextCam=0;
function newCam(t){ nextCam=t+4000+Math.random()*5000; tgtYaw=Math.random()*Math.PI*2; tgtPitch=(Math.random()-0.5)*Math.PI/2; tgtRad=6+Math.random()*8; }
/************** Mat4 helpers ***********/
function mat4Perspective(out,fovy,aspect,near,far){ const f=1/Math.tan(fovy/2),nf=1/(near-far); out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=(far+near)*nf;out[11]=-1;out[12]=0;out[13]=0;out[14]=2*far*near*nf;out[15]=0;return out; }
function mat4LookAt(out,ex,ey,ez){ const cx=0,cy=0,cz=0; let zx=ex-cx,zy=ey-cy,zz=ez-cz; let len=Math.hypot(zx,zy,zz); if(len===0)zz=1; else{ zx/=len; zy/=len; zz/=len;} let xx=-zy, xy=zx, xz=0; len=Math.hypot(xx,xy,xz); if(len!==0){ xx/=len; xy/=len; xz/=len;} let yx=zy*xz-zz*xy, yy=zz*xx-zx*xz, yz=zx*xy-zy*xx; out[0]=xx;out[1]=yx;out[2]=zx;out[3]=0; out[4]=xy;out[5]=yy;out[6]=zy;out[7]=0; out[8]=xz;out[9]=yz;out[10]=zz;out[11]=0; out[12]=-(xx*ex+xy*ey+xz*ez); out[13]=-(yx*ex+yy*ey+yz*ez); out[14]=-(zx*ex+zy*ey+zz*ez); out[15]=1; return out; }
/************** Main loop **************/
const fft=new Uint8Array(analyser.frequencyBinCount);
let last=performance.now();
function frame(now){ const dt=(now-last)*0.001; last=now; analyser.getByteFrequencyData(fft); let amp=0; for(let i=0;i<48;i++) amp+=fft[i]; amp/=48*255;
  if(now>nextCam) newCam(now);
  yaw+=(tgtYaw-yaw)*0.03; pitch+=(tgtPitch-pitch)*0.03; rad+=(tgtRad-rad)*0.03;
  const ex=Math.cos(yaw)*Math.cos(pitch)*rad; const ey=Math.sin(pitch)*rad; const ez=Math.sin(yaw)*Math.cos(pitch)*rad;
  const view=new Float32Array(16); mat4LookAt(view,ex,ey,ez);
  const proj=new Float32Array(16); mat4Perspective(proj,Math.PI/3,canvas.width/canvas.height,0.1,200);
  const uni=new Float32Array(UNI_SIZE/4); uni.set(proj,0); uni.set(view,16); uni[32]=amp; uni[33]=now*0.001; uni[34]=dt; device.queue.writeBuffer(uniformBuffer,0,uni);
  const encoder=device.createCommandEncoder();
  { const cpass=encoder.beginComputePass(); cpass.setPipeline(simPipeline); cpass.setBindGroup(0,bindGroup); cpass.dispatchWorkgroups(Math.ceil(COUNT/WORKGROUP_SIZE)); cpass.end(); }
  const rview=context.getCurrentTexture().createView();
  const rpass=encoder.beginRenderPass({ colorAttachments:[{view:rview,loadOp:'clear',storeOp:'store',clearValue:{r:0,g:0,b:0,a:1}}], depthStencilAttachment:{view:depthTex.createView(),depthClearValue:1,depthLoadOp:'clear',depthStoreOp:'discard'} });
  rpass.setPipeline(renderPipeline); rpass.setBindGroup(0,bindGroup); rpass.draw(COUNT); rpass.end();
  device.queue.submit([encoder.finish()]);
  requestAnimationFrame(frame);
}
canvas.addEventListener('click',()=>{ audioCtx.resume(); newCam(performance.now()); requestAnimationFrame(frame);},{once:true});
</script>
</body>
</html>
